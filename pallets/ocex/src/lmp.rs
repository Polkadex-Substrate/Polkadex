// This file is part of Polkadex.
//
// Copyright (c) 2022-2023 Polkadex o√º.
// SPDX-License-Identifier: GPL-3.0-or-later WITH Classpath-exception-2.0
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <https://www.gnu.org/licenses/>.

use crate::lmp::keys::{
	get_fees_paid_by_main_account, get_maker_volume_by_main_account_key,
	get_q_score_uptime_by_main_account, get_total_maker_volume_key,
	get_trade_volume_by_main_account_key,
};
use crate::{
	pallet::{IngressMessages, PriceOracle, TraderMetrics, TradingPairs},
	storage::OffchainState,
	BalanceOf, Config, Error, LMPEpoch, Pallet,
};
use frame_support::dispatch::DispatchResult;
use orderbook_primitives::constants::POLKADEX_MAINNET_SS58;
use orderbook_primitives::lmp::LMPConfig;
use orderbook_primitives::ocex::TradingPairConfig;
use orderbook_primitives::{
	types::{OrderSide, Trade, TradingPair},
	LiquidityMining,
};
use parity_scale_codec::alloc::string::ToString;
use parity_scale_codec::{Decode, Encode};
use polkadex_primitives::{AccountId, UNIT_BALANCE};
use rust_decimal::{
	prelude::{ToPrimitive, Zero},
	Decimal,
};
use sp_core::crypto::{Ss58AddressFormat, Ss58Codec};
use sp_runtime::{traits::BlockNumberProvider, DispatchError, SaturatedConversion};
use sp_std::{collections::btree_map::BTreeMap, vec::Vec};

pub const LMP_CONFIG_KEY: [u8; 14] = *b"LMP_CONFIG_KEY";

pub mod keys {
	use crate::lmp::LMP_CONFIG_KEY;
	use orderbook_primitives::types::TradingPair;
	use parity_scale_codec::Encode;
	use polkadex_primitives::AccountId;

	pub fn get_trade_volume_by_main_account_key(
		epoch: u16,
		pair: TradingPair,
		main: &AccountId,
	) -> Vec<u8> {
		(epoch, pair, "trading_volume", main).encode()
	}

	pub fn get_maker_volume_by_main_account_key(
		epoch: u16,
		pair: TradingPair,
		main: &AccountId,
	) -> Vec<u8> {
		(epoch, pair, "maker_volume", main).encode()
	}

	pub fn get_total_maker_volume_key(epoch: u16, pair: TradingPair) -> Vec<u8> {
		(epoch, pair, "maker_volume").encode()
	}

	pub fn get_fees_paid_by_main_account(
		epoch: u16,
		pair: TradingPair,
		main: &AccountId,
	) -> Vec<u8> {
		(epoch, pair, "fees_paid", main).encode()
	}

	#[allow(dead_code)]
	pub fn get_lmp_config_key() -> Vec<u8> {
		LMP_CONFIG_KEY.encode()
	}

	pub fn get_q_score_uptime_by_main_account(
		epoch: u16,
		pair: TradingPair,
		main: &AccountId,
	) -> Vec<u8> {
		(epoch, pair, "q_score&uptime", main).encode()
	}
}

/// Updates the trade volume generated by main account in offchain work state trie
pub fn update_trade_volume_by_main_account(
	state: &mut OffchainState,
	epoch: u16,
	market: &TradingPairConfig,
	volume: Decimal,
	main: &AccountId,
) -> Result<Decimal, &'static str> {
	let trading_pair = TradingPair::from(market.quote_asset, market.base_asset);
	let key = get_trade_volume_by_main_account_key(epoch, trading_pair, &main);
	Ok(match state.get(&key)? {
		None => {
			state.insert(key, volume.encode());
			volume
		},
		Some(encoded_volume) => {
			let recorded_volume = Decimal::decode(&mut &encoded_volume[..])
				.map_err(|_| "Unable to decode decimal")?;
			let total = recorded_volume.saturating_add(volume);
			state.insert(key, total.encode());
			total
		},
	})
}

/// Returns the trade volume generated by main account from offchain work state trie
pub fn get_trade_volume_by_main_account(
	state: &mut OffchainState,
	epoch: u16,
	trading_pair: &TradingPair,
	main: &AccountId,
) -> Result<Decimal, &'static str> {
	let key = get_trade_volume_by_main_account_key(epoch, *trading_pair, &main);
	Ok(match state.get(&key)? {
		None => Decimal::zero(),
		Some(encoded_volume) => {
			Decimal::decode(&mut &encoded_volume[..]).map_err(|_| "Unable to decode decimal")?
		},
	})
}

/// Returns the maker volume generated by main account from offchain work state trie
pub fn get_maker_volume_by_main_account(
	state: &mut OffchainState,
	epoch: u16,
	trading_pair: &TradingPair,
	main: &AccountId,
) -> Result<Decimal, &'static str> {
	let key = get_maker_volume_by_main_account_key(epoch, *trading_pair, &main);
	Ok(match state.get(&key)? {
		None => Decimal::zero(),
		Some(encoded_volume) => {
			Decimal::decode(&mut &encoded_volume[..]).map_err(|_| "Unable to decode decimal")?
		},
	})
}

/// Updates the maker volume generated by main account in offchain work state trie
pub fn update_maker_volume_by_main_account(
	state: &mut OffchainState,
	epoch: u16,
	market: &TradingPairConfig,
	volume: Decimal,
	main: &AccountId,
) -> Result<Decimal, &'static str> {
	let trading_pair = TradingPair::from(market.quote_asset, market.base_asset);
	let key = get_maker_volume_by_main_account_key(epoch, trading_pair, &main);
	Ok(match state.get(&key)? {
		None => {
			state.insert(key, volume.encode());
			volume
		},
		Some(encoded_volume) => {
			let recorded_volume = Decimal::decode(&mut &encoded_volume[..])
				.map_err(|_| "Unable to decode decimal")?;
			let total = recorded_volume.saturating_add(volume);
			state.insert(key, total.encode());
			total
		},
	})
}

/// Returns the total maker volume generated by main account from offchain work state trie
pub fn get_total_maker_volume(
	state: &mut OffchainState,
	epoch: u16,
	trading_pair: &TradingPair,
) -> Result<Decimal, &'static str> {
	if epoch.is_zero() {
		return Ok(Decimal::zero());
	}

	let key = get_total_maker_volume_key(epoch, *trading_pair);
	Ok(match state.get(&key)? {
		None => Decimal::zero(),
		Some(encoded_volume) => {
			Decimal::decode(&mut &encoded_volume[..]).map_err(|_| "Unable to decode decimal")?
		},
	})
}

/// Updates the total maker volume generated in that epoch in offchain work state trie
pub fn update_total_maker_volume(
	state: &mut OffchainState,
	epoch: u16,
	market: &TradingPairConfig,
	volume: Decimal,
) -> Result<Decimal, &'static str> {
	let trading_pair = TradingPair::from(market.quote_asset, market.base_asset);
	let key = get_total_maker_volume_key(epoch, trading_pair);
	Ok(match state.get(&key)? {
		None => {
			state.insert(key, volume.encode());
			volume
		},
		Some(encoded_volume) => {
			let recorded_volume = Decimal::decode(&mut &encoded_volume[..])
				.map_err(|_| "Unable to decode decimal")?;
			let total = recorded_volume.saturating_add(volume);
			state.insert(key, total.encode());
			total
		},
	})
}

/// Updates the trading fees generated by main account in offchain work state trie
pub fn store_fees_paid_by_main_account_in_quote(
	state: &mut OffchainState,
	epoch: u16,
	market: &TradingPairConfig,
	fees_in_quote_terms: Decimal,
	main: &AccountId,
) -> Result<Decimal, &'static str> {
	let trading_pair = TradingPair::from(market.quote_asset, market.base_asset);
	let key = get_fees_paid_by_main_account(epoch, trading_pair, main);
	Ok(match state.get(&key)? {
		None => {
			state.insert(key, fees_in_quote_terms.encode());
			fees_in_quote_terms
		},
		Some(encoded_fees_paid) => {
			let recorded_fees_paid = Decimal::decode(&mut &encoded_fees_paid[..])
				.map_err(|_| "Unable to decode decimal")?;
			let total_fees = recorded_fees_paid.saturating_add(fees_in_quote_terms);
			state.insert(key, total_fees.encode());
			total_fees
		},
	})
}

/// Returns the trading fees generated by main account from offchain work state trie
pub fn get_fees_paid_by_main_account_in_quote(
	state: &mut OffchainState,
	epoch: u16,
	trading_pair: &TradingPair,
	main: &AccountId,
) -> Result<Decimal, &'static str> {
	let key = get_fees_paid_by_main_account(epoch, *trading_pair, main);
	Ok(match state.get(&key)? {
		None => Decimal::zero(),
		Some(encoded_fees_paid) => {
			Decimal::decode(&mut &encoded_fees_paid[..]).map_err(|_| "Unable to decode decimal")?
		},
	})
}

/// Returns the LMP configuration from offchain work state trie
pub fn get_lmp_config(
	state: &mut OffchainState,
	current_on_chain_epoch: u16,
) -> Result<LMPConfig, &'static str> {
	let key = LMP_CONFIG_KEY.encode();
	Ok(match state.get(&key)? {
		None => {
			if current_on_chain_epoch == 0 {
				let config = LMPConfig { epoch: current_on_chain_epoch, index: 0 };
				store_lmp_config(state, config);
				return Ok(config);
			}
			return Err("LMPConfigNotFound");
		},
		Some(encoded_config) => LMPConfig::decode(&mut &encoded_config[..])
			.map_err(|_| "Unable to decode LMP config")?,
	})
}

/// Updates the LMP configuration in offchain work state trie
pub fn store_lmp_config(state: &mut OffchainState, config: LMPConfig) {
	let key = LMP_CONFIG_KEY.encode();
	state.insert(key, config.encode());
}

/// Updates the Q_score and uptime of given main account in offchain work state trie
pub fn store_q_score_and_uptime(
	state: &mut OffchainState,
	epoch: u16,
	index: u16,
	score: Decimal,
	trading_pair: &TradingPair,
	main: &AccountId,
) -> Result<(), &'static str> {
	let key = get_q_score_uptime_by_main_account(epoch, *trading_pair, main);
	match state.get(&key)? {
		None => state.insert(key, BTreeMap::from([(index, score)]).encode()),
		Some(encoded_q_scores_map) => {
			let mut map = BTreeMap::<u16, Decimal>::decode(&mut &encoded_q_scores_map[..])
				.map_err(|_| "Unable to decode decimal")?;
			if map.insert(index, score).is_some() {
				log::error!(target:"ocex","Overwriting q score with index: {:?}, epoch: {:?}, main: {:?}, market: {:?}",index,epoch,main,trading_pair);
				return Err("Overwriting q score");
			}
			log::info!(target: "ocex","Writing Q score and uptime for main: {:?}",main);
			state.insert(key, map.encode());
		},
	}
	Ok(())
}

/// Returns the total Q score and uptime
pub fn get_q_score_and_uptime(
	state: &mut OffchainState,
	epoch: u16,
	trading_pair: &TradingPair,
	main: &AccountId,
) -> Result<(Decimal, u16), &'static str> {
	let key = get_q_score_uptime_by_main_account(epoch, *trading_pair, main);
	match state.get(&key)? {
		None => {
			log::warn!(target:"ocex","q_score&uptime not found for: main: {:?}, market: {:?}",main.to_ss58check_with_version(Ss58AddressFormat::from(POLKADEX_MAINNET_SS58)), trading_pair.to_string());
			// If the q_score is not found, zero will be returned.
			Ok((Decimal::zero(), 0))
		},
		Some(encoded_q_scores_map) => {
			let map = BTreeMap::<u16, Decimal>::decode(&mut &encoded_q_scores_map[..])
				.map_err(|_| "Unable to decode decimal")?;
			let mut total_score = Decimal::zero();
			// Add up all individual scores
			for score in map.values() {
				total_score = total_score.saturating_add(*score);
			}
			Ok((total_score, map.len() as u16))
		},
	}
}

impl<T: Config> Pallet<T> {
	/// Updates the respective offchain DB trie keys for LMP metrics from given trade
	pub fn update_lmp_storage_from_trade(
		state: &mut OffchainState,
		trade: &Trade,
		config: TradingPairConfig,
		maker_fees: Decimal,
		taker_fees: Decimal,
	) -> Result<(), &'static str> {
		let epoch: u16 = <LMPEpoch<T>>::get();

		// Store trade.price * trade.volume as maker volume for this epoch
		let volume = trade.price.saturating_mul(trade.amount);
		// Update the trade volume generated to maker account
		update_trade_volume_by_main_account(
			state,
			epoch,
			&config,
			volume,
			&trade.maker.main_account,
		)?;
		// Update the trade volume generated to taker account
		update_trade_volume_by_main_account(
			state,
			epoch,
			&config,
			volume,
			&trade.taker.main_account,
		)?;
		// Update the maker volume generated to account
		update_maker_volume_by_main_account(
			state,
			epoch,
			&config,
			volume,
			&trade.maker.main_account,
		)?;
		// Update the total maker volume generated
		update_total_maker_volume(state, epoch, &config, volume)?;

		// Store maker_fees and taker_fees for the corresponding main account for this epoch
		match trade.maker.side {
			OrderSide::Ask => {
				let fees = maker_fees; // Maker fees is in quote because they put ask order.
				store_fees_paid_by_main_account_in_quote(
					state,
					epoch,
					&config,
					fees,
					&trade.maker.main_account,
				)?;

				// Convert taker fees to quote terms based on trade price
				let fees = taker_fees.saturating_mul(trade.price);
				store_fees_paid_by_main_account_in_quote(
					state,
					epoch,
					&config,
					fees,
					&trade.taker.main_account,
				)?;
			},
			OrderSide::Bid => {
				// Convert maker fees to quote terms based on trade price
				let fees = maker_fees.saturating_mul(trade.price);
				store_fees_paid_by_main_account_in_quote(
					state,
					epoch,
					&config,
					fees,
					&trade.maker.main_account,
				)?;

				// Taker fees is in quote because they put bid order.
				let fees = taker_fees.saturating_mul(trade.price);
				store_fees_paid_by_main_account_in_quote(
					state,
					epoch,
					&config,
					fees,
					&trade.taker.main_account,
				)?;
			},
		}
		Ok(())
	}

	/// Returns the top scored lmp account for the given epoch and market.
	pub fn top_lmp_accounts(
		epoch: u16,
		trading_pair: TradingPair,
		sorted_by_mm_score: bool,
		limit: usize,
	) -> Vec<T::AccountId> {
		let mut accounts: BTreeMap<Decimal, T::AccountId> = BTreeMap::new();
		let prefix = (epoch, trading_pair);
		for (main, (mm_score, trading_score, _)) in <TraderMetrics<T>>::iter_prefix(prefix) {
			if sorted_by_mm_score {
				accounts.insert(mm_score, main);
			} else {
				accounts.insert(trading_score, main);
			}
		}

		let mut accounts = accounts.values().cloned().collect::<Vec<T::AccountId>>();
		accounts.reverse(); // We want descending order

		if accounts.len() > limit {
			// Limit the items returned to top 'limit' accounts
			accounts = accounts.split_at(limit).0.to_vec()
		}

		accounts
	}
}

impl<T: Config> LiquidityMining<T::AccountId, BalanceOf<T>> for Pallet<T> {
	fn register_pool(pool_id: T::AccountId, trading_account: T::AccountId) -> DispatchResult {
		Self::register_user(pool_id, trading_account)
	}

	fn average_price(market: TradingPair) -> Option<Decimal> {
		let prices = <PriceOracle<T>>::get();
		prices.get(&(market.base, market.quote)).map(|(price, _ticks)| *price)
	}

	fn is_registered_market(market: &TradingPair) -> bool {
		<TradingPairs<T>>::contains_key(market.base, market.quote)
	}

	fn add_liquidity(
		market: TradingPair,
		pool: T::AccountId,
		lp: T::AccountId,
		total_shares_issued: Decimal,
		base_amount: Decimal,
		quote_amount: Decimal,
	) -> DispatchResult {
		let unit = Decimal::from(UNIT_BALANCE);
		let base_amount_in_u128 = base_amount
			.saturating_mul(unit)
			.to_u128()
			.ok_or(Error::<T>::FailedToConvertDecimaltoBalance)?;
		Self::do_deposit(pool.clone(), market.base, base_amount_in_u128.saturated_into())?;
		let quote_amount_in_u128 = quote_amount
			.saturating_mul(unit)
			.to_u128()
			.ok_or(Error::<T>::FailedToConvertDecimaltoBalance)?;
		Self::do_deposit(pool.clone(), market.quote, quote_amount_in_u128.saturated_into())?;
		let current_blk = frame_system::Pallet::<T>::current_block_number();
		<IngressMessages<T>>::mutate(current_blk, |messages| {
			messages.push(orderbook_primitives::ingress::IngressMessages::AddLiquidity(
				TradingPairConfig::default(market.base, market.quote),
				pool,
				lp,
				total_shares_issued,
				base_amount,
				quote_amount,
			));
		});
		Ok(())
	}

	fn remove_liquidity(
		market: TradingPair,
		pool: T::AccountId,
		lp: T::AccountId,
		burned: BalanceOf<T>,
		total: BalanceOf<T>,
	) {
		let burned = Decimal::from(burned.saturated_into::<u128>());
		let total = Decimal::from(total.saturated_into::<u128>());
		let burn_frac = burned.checked_div(total).unwrap_or_default();

		let current_blk = frame_system::Pallet::<T>::current_block_number();
		<IngressMessages<T>>::mutate(current_blk, |messages| {
			messages.push(orderbook_primitives::ingress::IngressMessages::RemoveLiquidity(
				TradingPairConfig::default(market.base, market.quote),
				pool,
				lp,
				burn_frac,
				total,
			));
		});
	}

	fn force_close_pool(market: TradingPair, pool: T::AccountId) {
		let current_blk = frame_system::Pallet::<T>::current_block_number();
		<IngressMessages<T>>::mutate(current_blk, |messages| {
			messages.push(orderbook_primitives::ingress::IngressMessages::ForceClosePool(
				TradingPairConfig::default(market.base, market.quote),
				pool,
			));
		});
	}

	fn claim_rewards(
		main: T::AccountId,
		epoch: u16,
		market: TradingPair,
	) -> Result<BalanceOf<T>, DispatchError> {
		Self::do_claim_lmp_rewards(main, epoch, market)
	}
}
