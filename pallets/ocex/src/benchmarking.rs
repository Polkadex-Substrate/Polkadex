// This file is part of Polkadex.

// Copyright (C) 2020-2022 Polkadex o√º.
// SPDX-License-Identifier: GPL-3.0-or-later WITH Classpath-exception-2.0

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.unwrap().

// You should have received a copy of the GNU General Public License
// along with this program. If not, see <https://www.gnu.org/licenses/>.

//! Benchmarking setup for pallet-ocex

use super::*;
use codec::Decode;
use frame_benchmarking::{account, benchmarks};
use frame_support::{traits::EnsureOrigin, BoundedVec};
use frame_system::RawOrigin;
use polkadex_primitives::{
	ocex::TradingPairConfig, snapshot::EnclaveSnapshot, withdrawal::Withdrawal, AccountId, Balance,
	WithdrawalLimit,
};
use sp_runtime::traits::CheckedConversion;

// Check if last event generated by pallet is the one we're expecting
fn assert_last_event<T: Config>(generic_event: <T as Config>::Event) {
	frame_system::Pallet::<T>::assert_last_event(generic_event.into());
}

// All benchmarks names match extrinsic names so we call them with `_()`
benchmarks! {
	register_main_account {
		let b in 0 .. 100_000;
		let origin = RawOrigin::Signed(account("caller", b, b));
		let account = T::AccountId::decode(&mut &[b as u8; 32].to_vec()[..]).unwrap();
		let main = ensure_signed(T::EnclaveOrigin::successful_origin()).unwrap();
	}: _(origin.clone(), account.clone().into())
	verify {
		assert_last_event::<T>(Event::MainAccountRegistered {
			main,
			proxy: account.into()
		}.into());
	}

	add_proxy_account {
		let x in 0 .. 100_000;
		let origin = RawOrigin::Signed(account("caller", x, x));
		let main = ensure_signed(T::EnclaveOrigin::successful_origin()).unwrap();
		let account = T::AccountId::decode(&mut &[x as u8; 32].to_vec()[..]).unwrap();
	}: _(origin.clone(), account.clone())
	verify {
		assert_last_event::<T>(Event::MainAccountRegistered {
			main,
			proxy: account
		}.into());
	}

	close_trading_pair {
		let x in 1 .. 100_000;
		let origin = RawOrigin::Signed(account("caller", x, x));
		let base = AssetId::decode(&mut &(x as u128).to_be_bytes()[..]).unwrap();
		let quote = AssetId::decode(&mut &((x + 1) as u128).to_be_bytes()[..]).unwrap();
		let config = TradingPairConfig {
			base_asset: base,
			quote_asset: quote,
			min_price: Decimal::from_f32(0.0001).unwrap(),
			max_price: Decimal::from_f32(100000.0).unwrap(),
			price_tick_size: Decimal::from_f32(0.000001).unwrap(),
			min_qty: Decimal::from_f64(0.001).unwrap(),
			max_qty: Decimal::from_f32(10000.0).unwrap(),
			qty_step_size: Decimal::from_f64(0.001).unwrap(),
			operational_status: true,
		};
		<TradingPairs<T>>::insert(base, quote, config);
		let trading_pair = <TradingPairs<T>>::get(base, quote).unwrap();
	}: _(origin, base, quote)
	verify {
		assert_last_event::<T>(Event::ShutdownTradingPair {
			pair: trading_pair
		}.into());
	}

	open_trading_pair {
		let x in 0 .. 100_000;
		let origin = RawOrigin::Signed(account("caller", x, x));
		let base = AssetId::decode(&mut &(x as u128).to_be_bytes()[..]).unwrap();
		let quote = AssetId::decode(&mut &((x + 1) as u128).to_be_bytes()[..]).unwrap();
		let config = TradingPairConfig {
			base_asset: base,
			quote_asset: quote,
			min_price: Decimal::from_f32(0.0001).unwrap(),
			max_price: Decimal::from_f32(100000.0).unwrap(),
			price_tick_size: Decimal::from_f32(0.000001).unwrap(),
			min_qty: Decimal::from_f64(0.001).unwrap(),
			max_qty: Decimal::from_f32(10000.0).unwrap(),
			qty_step_size: Decimal::from_f64(0.001).unwrap(),
			operational_status: true,
		};
		<TradingPairs<T>>::insert(base, quote, config);
		let trading_pair = <TradingPairs<T>>::get(base, quote).unwrap();
	}: _(origin, base, quote)
	verify {
		assert_last_event::<T>(Event::OpenTradingPair {
			pair: trading_pair
		}.into());
	}

	register_trading_pair {
		let x in 0 .. 100_000;
		let origin = RawOrigin::Signed(account("caller", x, x));
		let base = AssetId::decode(&mut &(x as u128).to_be_bytes()[..]).unwrap();
		let quote = AssetId::decode(&mut &((x + 1) as u128).to_be_bytes()[..]).unwrap();
		let balance = BalanceOf::<T>::decode(&mut &(x as u128).to_be_bytes()[..]).unwrap();
		let zero = BalanceOf::<T>::decode(&mut &(0 as u128).to_be_bytes()[..]).unwrap();
	}: _(origin, base, quote, balance, balance, balance, balance, zero, zero)
	verify {
		assert_last_event::<T>(Event::TradingPairRegistered {
			base,
			quote
		}.into());
	}

	update_trading_pair {
		let x in 0 .. 100_000;
		let origin = RawOrigin::Signed(account("caller", x, x));
		let base = AssetId::decode(&mut &(x as u128).to_be_bytes()[..]).unwrap();
		let quote = AssetId::decode(&mut &((x + 1) as u128).to_be_bytes()[..]).unwrap();
		let balance = BalanceOf::<T>::decode(&mut &(x as u128).to_be_bytes()[..]).unwrap();
		let zero = BalanceOf::<T>::decode(&mut &(0 as u128).to_be_bytes()[..]).unwrap();
	}: _(origin, base, quote, balance, balance, balance, balance, zero, zero)
	verify {
		assert_last_event::<T>(Event::TradingPairRegistered {
			base,
			quote
		}.into());
	}

	deposit {
		let x in 0 .. 100_000;
		let origin = RawOrigin::Signed(account("caller", x, x));
		let user = ensure_signed(T::EnclaveOrigin::successful_origin()).unwrap();
		let asset = AssetId::decode(&mut &((x  + 1) as u128).to_be_bytes()[..]).unwrap();
		let amount  = BalanceOf::<T>::decode(&mut &(x as u128).to_be_bytes()[..]).unwrap();
	}: _(origin, asset, amount)
	verify {
		assert_last_event::<T>(Event::DepositSuccessful {
			user,
			asset,
			amount
		}.into());
	}

	remove_proxy_account {
		let x in 0 .. 100_000;
		let origin = RawOrigin::Signed(account("caller", x, x));
		let main = ensure_signed(T::EnclaveOrigin::successful_origin()).unwrap();
		let account = T::AccountId::decode(&mut &[x as u8; 32].to_vec()[..]).unwrap();
	}: _(origin.clone(), account.clone())
	verify {
		assert_last_event::<T>(Event::MainAccountRegistered {
			main,
			proxy: account
		}.into());
	}

	submit_snapshot {
		let x in 0 .. 65_000;
		let origin = RawOrigin::Signed(account("caller", x, x));
		let snapshot = EnclaveSnapshot {
			snapshot_number: x,
			snapshot_hash: H256::from([x as u8; 32]),
			withdrawals: Default::default(),
			fees: Default::default()
		};
		let bytes = snapshot.encode();
		let signature: T::Signature = origin.sign(&bytes);
	}: _(origin, snapshot, signature)
	verify {
		assert!(<Snapshots<T>>::contains_key(x));
	}

	insert_enclave {
		let x in 0 .. 100_000;
		let origin = T::GovernanceOrigin::successful_origin();
		let enclave = T::AccountId::decode(&mut &[x as u8; 32][..]).unwrap();
	}: _(origin, enclave.clone())
	verify {
		assert!(<RegisteredEnclaves<T>>::contains_key(enclave));
	}

	collect_fees {
		let x in 0 .. 100_000;
		let origin = T::GovernanceOrigin::successful_origin();
		let benefic = T::AccountId::decode(&mut &[x as u8; 32][..]).unwrap();
		let fees: Fees = Fees { asset: AssetId::polkadex, amount: Decimal::new(100, 1) };
		let snapshot =
			EnclaveSnapshot::<AccountId32, WithdrawalLimit, AssetsLimit, SnapshotAccLimit> {
				snapshot_number: x.into(),
				snapshot_hash: H256::from([x as u8; 32]),
				withdrawals: Default::default(),
				fees: bounded_vec![fees],
			};
		<Snapshots<T>>::insert(snapshot);
	}: _(origin, x, benefic.clone())
	verify {
		assert_last_event::<T>(Event::FeesClaims{benefic, x}.into());
	}

	shutdown {
		let x in 0 .. 100_000;
		let state = x % 2 == 0;
		let origin = T::GovernanceOrigin::successful_origin();
		<ExchangeState<T>>::put(state);
	}: _(origin, !state)
	verify {
		assert_eq!(<ExchanegState<T>>::get(), !state);
		assert_eq!(<IngeressMessages<T>>::get().last(), polkadex_primitives::ingress::IngressMessages::Shutdown);
	}

	set_exchange_state {
		todo!()
	}: _()
	verify {
		assert!(true)
	}

	claim_withdraw {
		let x in 0 .. 100_000;
		let origin = RawOrigin::Signed(account("caller", x, x));
		let main = ensure_signed(T::EnclaveOrigin::successful_origin()).unwrap();
		let asset = AssetId::decode(&mut &(x as u128).to_be_bytes()[..]).unwrap();
		let amount = BalanceOf::<T>::decode(&mut &(x as u128).to_be_bytes()[..]).unwrap();
		let mut withdrawals = Vec::with_capacity(1);
		withdrawals.push(Withdrawal {
				amount: BalanceOf::<T>::decode(&mut (x as u128).to_be_bytes().to_vec().as_ref()).unwrap(),
				asset,
				main_account: main.clone()
			});
		let mut withdrawals: BoundedVec<Withdrawal<T::AccountId, BalanceOf<T>>, WithdrawalLimit> = frame_support::BoundedVec::try_from(withdrawals).unwrap();
		<Withdrawals<T>>::insert(x, withdrawals);
	}: _(origin, x, x)
	verify {
		assert_last_event::<T>(Event::WithdrawalClaimed {
			main,
			asset,
			amount,
			snapshot_id: x,
			withdrawal_index: 0
		}.into());
	}

	register_enclave {
		let x in 0 .. 65_000;
		use test_utils::{get_signer, ias::{consts::*, ias::*}};
		timestamp::Pallet::<T>::set_timestamp(TEST4_SETUP.timestamp.checked_into().unwrap());
		let signer: T::AccountId = T::AccountId::decode(&mut &TEST4_SETUP.signer_pub[..]).unwrap();
	}: _(RawOrigin::Signed(signer.clone()), TEST4_SETUP.cert.to_vec())
	verify {
		assert_last_event::<T>(Event::EnclaveRegistered(signer).into());
	}

	allowlist_token {
		let x in 0 .. 65_000;
		let origin = T::GovernanceOrigin::successful_origin();
		let asset_id = AssetId::asset(x);
	}: _(origin, asset_id)
	verify {
		assert_last_event::<T>(Event::TokenAllowlisted(asset_id).into());
	}

	remove_allowlisted_token {
		let x in 0 .. 65_000;
		let origin = T::GovernanceOrigin::successful_origin();
		let asset_id = AssetId::asset(x);
		<AllowlistedToken<T>>::insert(asset_id);
	}: _(origin, asset_id)
	verify {
		assert_last_event::<T>(Event::AllowlistedTokenRemoved(asset_id).into());
	}

	allowlist_enclave {
		let x in 0 .. 65_000;
		let origin = T::GovernanceOrigin::successful_origin();
		let account = T::AccountId::decode(&mut &[x as u8; 32].to_vec()[..]).unwrap();
	}: _(origin, account.clone())
	verify {
		assert_last_event::<T>(Event::EnclaveAllowlisted(account).into());
	}

	impl_benchmark_test_suite!(Pallet, crate::tests::new_test_ext(), crate::tests::Test);
}
