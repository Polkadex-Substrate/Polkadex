// This file is part of Polkadex.

// Copyright (C) 2020-2023 Polkadex o√º.
// SPDX-License-Identifier: GPL-3.0-or-later WITH Classpath-exception-2.0

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program. If not, see <https://www.gnu.org/licenses/>.

//! Benchmarking setup for pallet-thea
#![cfg(feature = "runtime-benchmarks")]

use super::*;
use crate::Pallet as Thea;
use frame_benchmarking::{account, benchmarks};
use frame_support::{dispatch::UnfilteredDispatchable, traits::EnsureOrigin};
use frame_system::RawOrigin;
use parity_scale_codec::Decode;
use polkadex_primitives::{misbehavior::TheaMisbehavior, UNIT_BALANCE};
use sp_runtime::traits::Zero;
use sp_std::vec;

// Check if last event generated by pallet is the one we're expecting
fn assert_last_event<T: Config>(generic_event: <T as Config>::Event) {
	frame_system::Pallet::<T>::assert_last_event(generic_event.into());
}

fn convert_to_balance<T: Config>(dec: u32) -> BalanceOf<T> {
	BalanceOf::<T>::decode(&mut &(dec as u128).saturating_mul(UNIT_BALANCE).to_le_bytes()[..])
		.unwrap()
}

benchmarks! {
	approve_deposit {
		let a in 1 .. 10;
		let m in 100 .. u32::MAX;
		let balance: BalanceOf<T> = convert_to_balance::<T>(m);
		let staking_limits = StakingLimits {
			mininum_relayer_stake: balance,
			minimum_nominator_stake: balance,
			maximum_nominator_per_relayer: 10,
			max_relayers: a,
		};
		let call = Call::<T>::approve_deposit{ staking_limits };
	}: { call.dispatch_bypass_filter(RawOrigin::Root.into())? }

	claim_deposit {
		let a in 0 .. 255;
		let b in 0 .. 255;
		let m in 100 .. u32::MAX;
		let candidate: T::AccountId = account::<T::AccountId>("candidate", b, 0);
		let balance: BalanceOf<T> = convert_to_balance::<T>(m);
		drop(<pallet_balances::Pallet<T> as Currency<_>>::deposit_creating(&candidate, balance));
		let bls_key = BLSPublicKey([b.try_into().unwrap(); 192]);
		let call = Call::<T>::claim_deposit{ network: a as u8, bls_key };
	}: { call.dispatch_bypass_filter(RawOrigin::Signed(candidate.clone()).into())? }
	verify {
		assert_last_event::<T>(Event::CandidateRegistered{candidate, stake: T::CandidateBond::get()}.into());
	}

	batch_withdrawal_complete {
		let m in 100 .. u32::MAX;
		let k in 1 .. 255;
		let x in 1 .. 255;
		let candidate = account::<T::AccountId>("candidate", x, 0);
		let nominator = account::<T::AccountId>("nominator", k, 0);
		let balance: BalanceOf<T> = convert_to_balance::<T>(m);
		stake_nominator_candidate::<T>(k, nominator.clone(), candidate.clone(), balance);
		let call = Call::<T>::batch_withdrawal_complete{ candidate: candidate.clone() };
	}: { call.dispatch_bypass_filter(RawOrigin::Signed(nominator.clone()).into())? }
	verify {
		assert_last_event::<T>(Event::Nominated { candidate, nominator }.into());
	}

	withdraw {
		let m in 100 .. u32::MAX;
		let k in 1 .. 255;
		let x in 1 .. 255;
		let nominator = account::<T::AccountId>("nominator", k, 0);
		let candidate = account::<T::AccountId>("candidate", x, 0);
		let amount: BalanceOf<T> = convert_to_balance::<T>(m);
		stake_nominator_candidate::<T>(k, nominator.clone(), candidate.clone(), amount);
		TheaStaking::<T>::nominate(RawOrigin::Signed(nominator.clone()).into(), candidate.clone()).unwrap();
		let call = Call::<T>::withdraw{ amount, candidate: candidate.clone() };
	}: { call.dispatch_bypass_filter(RawOrigin::Signed(nominator.clone()).into())? }
	verify{
		assert_last_event::<T>(Event::Bonded{ candidate, nominator, amount }.into());
	}

	set_withdrawal_fee {
		let m in 100 .. u32::MAX;
		let k in 1 .. 255;
		let x in 1 .. 255;
		let candidate = account::<T::AccountId>("candidate", x, 0);
		let nominator = account::<T::AccountId>("nominator", k, 0);
		let amount: BalanceOf<T> = convert_to_balance::<T>(m);
		stake_nominator_candidate::<T>(k, nominator.clone(), candidate.clone(), amount);
		TheaStaking::<T>::nominate(RawOrigin::Signed(nominator.clone()).into(), candidate.clone()).unwrap();
		TheaStaking::<T>::bond(RawOrigin::Signed(nominator.clone()).into(), amount, candidate.clone()).unwrap();
		let call = Call::<T>::unbond { amount };
	}: { call.dispatch_bypass_filter(RawOrigin::Signed(nominator.clone()).into())? }
	verify {
		// None - as two events emmited, and only first one can have Some(candidate)
		assert_last_event::<T>(Event::Unbonded{ candidate, nominator, amount }.into());
	}

	thea_key_rotation_complete {
		let m in 100_000_000 .. u32::MAX;
		let k in 1 .. 255;
		let x in 1 .. 255;
		let nominator = account::<T::AccountId>("nominator", k, 0);
		let candidate = account::<T::AccountId>("candidate", x, 0);
		let amount: BalanceOf<T> = convert_to_balance::<T>(m);
		let bound_amount: BalanceOf<T> = convert_to_balance::<T>(m - 10);
		assert_ne!(amount, Zero::zero());
		<CurrentIndex<T>>::put(1);
		stake_nominator_candidate::<T>(k, nominator.clone(), candidate.clone(), amount);
		TheaStaking::<T>::nominate(RawOrigin::Signed(nominator.clone()).into(), candidate.clone())?;
		TheaStaking::<T>::bond(RawOrigin::Signed(nominator.clone()).into(), amount, candidate.clone())?;
		// elect exposure
		let exposure = <Candidates<T>>::get(1, &candidate).unwrap();
		<TotalElectedRelayers<T>>::insert(1, vec!((nominator.clone(), exposure)));
		TheaStaking::<T>::unbond(RawOrigin::Signed(nominator.clone()).into(), amount)?;
		let prev_index = TheaStaking::<T>::current_index();
		let ud = T::UnbondingDelay::get();
		<CurrentIndex<T>>::put(prev_index + ud);
		let call = Call::<T>::thea_key_rotation_complete{};
	}: { call.dispatch_bypass_filter(RawOrigin::Signed(nominator.clone()).into())? }
	verify {
		assert_last_event::<T>(Event::BondsWithdrawn{ nominator, amount }.into());
	}

	set_thea_key_complete {
		let m in 100 .. u32::MAX;
		let k in 1 .. 255;
		let candidate = account::<T::AccountId>("candidate", k, 0);
		// register stake
		let bls_key: BLSPublicKey = BLSPublicKey([k as u8; 192]);
		let balance: BalanceOf<T> = convert_to_balance::<T>(m);
		let exposure = Exposure {
			score: 1000,
			total: balance,
			individual: balance,
			bls_pub_key: bls_key,
			stakers: Default::default(),
		};
		<Candidates<T>>::insert(1, candidate.clone(), exposure);
		let call = Call::<T>::set_thea_key_complete{ network: 1 };
	}: { call.dispatch_bypass_filter(RawOrigin::Signed(candidate.clone()).into())? }
	verify {
		assert_last_event::<T>(Event::OutgoingCandidateAdded{ candidate }.into());
	}

	thea_queued_queued_public_key {
		let n in 1 .. 255;
		let network: u8 = n as u8;
		let go = T::GovernanceOrigin::successful_origin();
		let call = Call::<T>::thea_queued_queued_public_key{ network };
	}: { call.dispatch_bypass_filter(go)? }
	verify {
		assert_last_event::<T>(Event::NetworkAdded{ network }.into());
	}

	thea_relayers_reset_rotation {
		let n in 1 .. 255;
		let network: u8 = n as u8;
		let go = T::GovernanceOrigin::successful_origin();
		TheaStaking::<T>::add_network(go.clone(), network).unwrap();
		let call = Call::<T>::thea_relayers_reset_rotation{ network };
	}: { call.dispatch_bypass_filter(go)? }
	verify {
		assert_last_event::<T>(Event::NetworkRemoved{ network }.into());
	}
}

#[cfg(test)]
use frame_benchmarking::impl_benchmark_test_suite;

#[cfg(test)]
impl_benchmark_test_suite!(Thea, crate::mock::new_test_ext(), crate::mock::Test);
