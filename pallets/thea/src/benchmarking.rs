// This file is part of Polkadex.
//
// Copyright (c) 2022-2023 Polkadex o√º.
// SPDX-License-Identifier: GPL-3.0-or-later WITH Classpath-exception-2.0
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <https://www.gnu.org/licenses/>.

//! Benchmarking setup for pallet-ocex
#![cfg(feature = "runtime-benchmarks")]

use super::*;
use crate::Pallet as Thea;
use bls_primitives::{Public, Signature};
use frame_benchmarking::{account, benchmarks};
use frame_support::{dispatch::UnfilteredDispatchable, traits::EnsureOrigin, BoundedVec};
use frame_system::RawOrigin;
use parity_scale_codec::Decode;
use sp_core::crypto::ByteArray;
use sp_runtime::{
	traits::{BlockNumberProvider, One},
	BoundedBTreeSet,
};
use thea_primitives::types::Message;

// Check if last event generated by pallet is the one we're expecting
fn assert_last_event<T: Config>(generic_event: <T as Config>::RuntimeEvent) {
	frame_system::Pallet::<T>::assert_last_event(generic_event.into());
}

benchmarks! {
	update_network_pref {
		let b in 1 .. 255; // keep within u8 range
		let authority = <T as crate::Config>::TheaId::decode(&mut Public([b as u8; 96]).encode().as_ref()).unwrap();
		let network = b as u8;
		let signature = <T as crate::Config>::Signature::decode(&mut Signature([b as u8; 48]).encode().as_ref()).unwrap();
	}: _(RawOrigin::None, authority, network, signature)
	verify {
		assert_last_event::<T>(Event::NetworkUpdated { authority, network}.into());
	}

	incoming_message {
		let b in 0 .. 256; // keep withing u8 range
		let message = Message {
			block_no: b as u64,
			nonce: 0,
			data: [b as u8; 1_048_576].into(), //10 MB
			network: b as u8,
			is_key_change: false,
			validator_set_id: 0,
			validator_set_len: 1
		};
		let payload = b"";
		let signature = <T as crate::Config>::Signature::decode(&mut b"".as_ref()).unwrap();
		<Authorities::<T>>::insert(b as u8, 0, vec!(Public([0u8; 96])).try_into().unwrap());
		let bitmap = vec!(u128::MAX); // ALL bits are set :)
	}: _(RawOrigin::None, bitmap, message, signature)
	verify {
		assert!(<IncomingNonce::<T>>::get(0) == 1);
		assert!(<IncomingMessages::<T>>::iter().count() == 1);
	}

	send_thea_message {
		let b in 0 .. 256; // keep within u8 bounds
		let key = ();
		let network = 0 as u8;
		let data = [b as u8; 1_048_576].to_vec(); // 10MB
		let set: BoundedVec<<T as crate::Config>::TheaId, <T as crate::Config>::MaxAuthorities>= vec!(key).into();
		<Authorities::<T>>::insert(network, 0, set);
	}: _(RawOrigin::Root, data, network)
	verify {
		assert!(<OutgoingNonce::<T>>::get(network) == 1);
		assert!(<OutgoingMessages::<T>>::iter().count() == 1);
	}

	update_incoming_nonce {
		let b in 0 .. 50_000;
		let network = 0;
		let nonce: u64 = b.into();
	}: _(RawOrigin::Root, nonce, network)
	verify {
		assert!(<IncomingNonce::<T>>::get(network) == b.into());
	}
}
//
//#[cfg(test)]
//use frame_benchmarking::impl_benchmark_test_suite;
//
//#[cfg(test)]
//impl_benchmark_test_suite!(Thea, crate::mock::new_test_ext(), crate::mock::Test);
