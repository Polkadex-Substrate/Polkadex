// This file is part of Polkadex.

// Copyright (C) 2020-2023 Polkadex o√º.
// SPDX-License-Identifier: GPL-3.0-or-later WITH Classpath-exception-2.0

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program. If not, see <https://www.gnu.org/licenses/>.

//! Benchmarking setup for pallet-thea
//#![cfg(feature = "runtime-benchmarks")]

use super::*;
use frame_benchmarking::{account, benchmarks};
use frame_support::{dispatch::UnfilteredDispatchable, traits::fungibles::Mutate, BoundedVec};
use frame_system::{Config, RawOrigin};
use pallet_balances as _;
use sp_core::{H160, H256};
use sp_runtime::traits::{ConstU32, StaticLookup};
use sp_std::{boxed::Box, vec};
use thea_primitives::{ApprovedWithdraw, TokenType};
use xcm::latest::{AssetId, Junctions, MultiLocation};

// Check if last event generated by pallet is the one we're expecting
fn assert_last_event<T: Config + pallet::Config>(generic_event: <T as pallet::Config>::RuntimeEvent) {
	frame_system::Pallet::<T>::assert_last_event(generic_event.into());
}

fn to_balance<T: pallet_balances::Config>(numeric: u128) -> T::Balance {
	<T as pallet_balances::Config>::Balance::decode(&mut numeric.to_le_bytes().as_ref()).unwrap()
}

fn unlookup<T: pallet_balances::Config + Config>(
	acc: <T as Config>::AccountId,
) -> <T::Lookup as StaticLookup>::Source {
	T::Lookup::unlookup(acc)
}

const SIGNATURE: [u8; 96] = [
	21, 215, 123, 153, 74, 251, 176, 4, 118, 253, 52, 161, 223, 105, 74, 124, 80, 152, 195, 211,
	222, 15, 76, 227, 1, 21, 96, 250, 249, 16, 65, 144, 170, 210, 168, 32, 155, 107, 106, 238, 7,
	51, 96, 177, 155, 14, 209, 10, 20, 148, 25, 173, 104, 18, 72, 175, 131, 8, 188, 212, 239, 232,
	177, 162, 1, 168, 49, 28, 230, 119, 43, 202, 83, 195, 141, 21, 239, 96, 1, 165, 163, 182, 182,
	61, 166, 172, 197, 228, 0, 183, 91, 79, 87, 106, 205, 198,
];
const BIT_MAP: u128 = 3;
const PAYLOAD: [u8; 78] = [
	0, 1, 1, 0, 6, 196, 28, 36, 60, 116, 41, 76, 197, 21, 40, 124, 17, 142, 128, 189, 115, 168,
	219, 199, 151, 158, 208, 8, 177, 131, 105, 116, 42, 17, 129, 26, 0, 1, 0, 0, 40, 1, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
];
const ID: [u8; 32] = [
	6, 196, 28, 36, 60, 116, 41, 76, 197, 21, 40, 124, 17, 142, 128, 189, 115, 168, 219, 199, 151,
	158, 208, 8, 177, 131, 105, 116, 42, 17, 129, 26,
];
const PK1: BLSPublicKey = BLSPublicKey([
	18, 197, 237, 44, 126, 194, 180, 119, 175, 48, 180, 169, 64, 255, 129, 227, 103, 190, 202, 14,
	28, 249, 141, 168, 91, 231, 160, 85, 38, 64, 215, 169, 8, 63, 84, 228, 68, 221, 231, 76, 213,
	34, 178, 2, 129, 190, 160, 222, 20, 51, 200, 177, 82, 242, 137, 190, 88, 136, 144, 174, 79,
	217, 207, 179, 161, 106, 57, 191, 229, 29, 82, 86, 21, 99, 199, 197, 125, 237, 38, 44, 241,
	155, 99, 156, 2, 213, 230, 105, 106, 122, 44, 246, 1, 55, 209, 123, 8, 116, 46, 106, 198, 67,
	48, 92, 82, 185, 122, 90, 227, 88, 24, 235, 176, 52, 75, 207, 178, 217, 254, 38, 47, 228, 58,
	187, 170, 21, 197, 107, 47, 213, 1, 116, 200, 200, 25, 146, 9, 98, 121, 191, 246, 195, 178,
	123, 1, 81, 193, 207, 246, 50, 209, 196, 254, 50, 40, 48, 235, 13, 124, 252, 240, 18, 89, 96,
	226, 5, 117, 11, 189, 141, 189, 210, 212, 217, 67, 201, 208, 238, 202, 218, 50, 46, 139, 142,
	193, 150, 52, 137, 46, 169, 20, 167,
]);
const PK2: BLSPublicKey = BLSPublicKey([
	18, 163, 116, 54, 177, 117, 234, 160, 132, 146, 93, 176, 156, 40, 130, 224, 77, 56, 89, 191,
	235, 175, 56, 1, 84, 163, 135, 231, 94, 214, 245, 135, 94, 58, 149, 227, 59, 107, 15, 59, 161,
	62, 221, 118, 72, 102, 226, 40, 7, 5, 114, 28, 78, 166, 253, 106, 168, 36, 194, 90, 246, 76,
	252, 76, 140, 230, 212, 188, 201, 67, 166, 230, 246, 241, 69, 184, 20, 229, 180, 115, 47, 255,
	211, 99, 210, 154, 251, 135, 130, 85, 33, 205, 137, 86, 100, 237, 13, 93, 88, 166, 66, 71, 118,
	204, 249, 132, 241, 222, 191, 75, 41, 39, 219, 19, 55, 242, 77, 213, 210, 81, 14, 28, 50, 223,
	129, 208, 249, 62, 30, 50, 61, 170, 67, 104, 103, 171, 82, 11, 113, 98, 87, 130, 140, 205, 8,
	90, 213, 122, 189, 151, 159, 25, 48, 123, 148, 196, 126, 5, 40, 109, 183, 223, 254, 140, 147,
	68, 93, 138, 89, 184, 66, 136, 138, 76, 62, 104, 110, 89, 22, 248, 56, 113, 124, 93, 27, 78,
	163, 122, 241, 0, 251, 55,
]);
const PK3: BLSPublicKey = BLSPublicKey([
	4, 45, 89, 104, 18, 181, 135, 112, 206, 129, 195, 7, 58, 161, 223, 167, 152, 1, 217, 251, 80,
	224, 83, 102, 130, 62, 22, 183, 38, 20, 27, 174, 181, 154, 155, 156, 123, 84, 90, 20, 54, 30,
	145, 152, 209, 121, 93, 233, 23, 70, 142, 138, 87, 242, 100, 206, 237, 228, 108, 23, 217, 206,
	241, 217, 206, 56, 136, 159, 109, 239, 234, 115, 189, 76, 164, 33, 250, 12, 135, 103, 31, 92,
	168, 53, 127, 55, 16, 98, 42, 192, 51, 147, 169, 42, 185, 192, 0, 152, 219, 106, 163, 59, 138,
	124, 197, 67, 126, 79, 190, 118, 182, 192, 216, 201, 32, 136, 154, 255, 251, 208, 132, 160,
	232, 237, 104, 78, 122, 51, 66, 62, 179, 139, 252, 79, 4, 213, 153, 210, 37, 186, 81, 59, 207,
	51, 3, 121, 216, 166, 152, 107, 208, 227, 165, 233, 52, 194, 174, 197, 240, 166, 235, 32, 66,
	151, 235, 9, 239, 75, 208, 212, 102, 93, 230, 137, 186, 198, 175, 236, 125, 233, 218, 72, 44,
	148, 109, 157, 221, 99, 246, 251, 2, 71,
]);

benchmarks! {
	where_clause { where T: Config + pallet::Config + asset_handler::pallet::Config + pallet_assets::Config + thea_staking::Config }

	// works
	approve_deposit {
		let origin = account::<T::AccountId>("1", 0, 0);
		let asset_id = AssetId::Concrete(MultiLocation { parents: 1, interior: Junctions::Here });
		const R: [BLSPublicKey; 3] = [BLSPublicKey([15, 76, 33, 103, 184, 172, 12, 111, 24, 87, 84, 61, 243, 82, 99, 76, 131, 95, 171, 237, 145, 143, 7, 93, 205, 148, 104, 29, 153, 103, 187, 206, 112, 223, 252, 198, 102, 41, 38, 244, 228, 223, 102, 16, 216, 152, 231, 250, 7, 111, 90, 98, 194, 244, 101, 251, 69, 130, 11, 209, 41, 210, 133, 105, 217, 179, 190, 1, 6, 155, 135, 2, 168, 249, 253, 41, 59, 87, 8, 49, 231, 198, 142, 30, 186, 44, 175, 17, 198, 63, 210, 176, 237, 171, 11, 127, 16, 47, 17, 152, 208, 121, 185, 37, 152, 66, 209, 104, 136, 143, 15, 192, 107, 28, 160, 193, 150, 200, 241, 19, 95, 238, 75, 30, 182, 7, 49, 74, 36, 158, 210, 87, 82, 2, 239, 75, 3, 201, 103, 230, 72, 168, 97, 199, 17, 157, 105, 84, 120, 165, 43, 137, 27, 189, 64, 161, 22, 49, 179, 96, 136, 111, 99, 222, 184, 193, 166, 236, 114, 182, 38, 65, 187, 180, 178, 58, 54, 69, 172, 204, 218, 206, 68, 105, 57, 17, 231, 112, 228, 23, 28, 112]), BLSPublicKey([18, 197, 237, 44, 126, 194, 180, 119, 175, 48, 180, 169, 64, 255, 129, 227, 103, 190, 202, 14, 28, 249, 141, 168, 91, 231, 160, 85, 38, 64, 215, 169, 8, 63, 84, 228, 68, 221, 231, 76, 213, 34, 178, 2, 129, 190, 160, 222, 20, 51, 200, 177, 82, 242, 137, 190, 88, 136, 144, 174, 79, 217, 207, 179, 161, 106, 57, 191, 229, 29, 82, 86, 21, 99, 199, 197, 125, 237, 38, 44, 241, 155, 99, 156, 2, 213, 230, 105, 106, 122, 44, 246, 1, 55, 209, 123, 8, 116, 46, 106, 198, 67, 48, 92, 82, 185, 122, 90, 227, 88, 24, 235, 176, 52, 75, 207, 178, 217, 254, 38, 47, 228, 58, 187, 170, 21, 197, 107, 47, 213, 1, 116, 200, 200, 25, 146, 9, 98, 121, 191, 246, 195, 178, 123, 1, 81, 193, 207, 246, 50, 209, 196, 254, 50, 40, 48, 235, 13, 124, 252, 240, 18, 89, 96, 226, 5, 117, 11, 189, 141, 189, 210, 212, 217, 67, 201, 208, 238, 202, 218, 50, 46, 139, 142, 193, 150, 52, 137, 46, 169, 20, 167]), BLSPublicKey([18, 163, 116, 54, 177, 117, 234, 160, 132, 146, 93, 176, 156, 40, 130, 224, 77, 56, 89, 191, 235, 175, 56, 1, 84, 163, 135, 231, 94, 214, 245, 135, 94, 58, 149, 227, 59, 107, 15, 59, 161, 62, 221, 118, 72, 102, 226, 40, 7, 5, 114, 28, 78, 166, 253, 106, 168, 36, 194, 90, 246, 76, 252, 76, 140, 230, 212, 188, 201, 67, 166, 230, 246, 241, 69, 184, 20, 229, 180, 115, 47, 255, 211, 99, 210, 154, 251, 135, 130, 85, 33, 205, 137, 86, 100, 237, 13, 93, 88, 166, 66, 71, 118, 204, 249, 132, 241, 222, 191, 75, 41, 39, 219, 19, 55, 242, 77, 213, 210, 81, 14, 28, 50, 223, 129, 208, 249, 62, 30, 50, 61, 170, 67, 104, 103, 171, 82, 11, 113, 98, 87, 130, 140, 205, 8, 90, 213, 122, 189, 151, 159, 25, 48, 123, 148, 196, 126, 5, 40, 109, 183, 223, 254, 140, 147, 68, 93, 138, 89, 184, 66, 136, 138, 76, 62, 104, 110, 89, 22, 248, 56, 113, 124, 93, 27, 78, 163, 122, 241, 0, 251, 55])];
		RelayersBLSKeyVector::<T>::insert(1, R.to_vec());
		asset_handler::pallet::Pallet::<T>::create_parachain_asset(
			<T as asset_handler::pallet::Config>::AssetCreateUpdateOrigin::successful_origin(),
			Box::from(asset_id)
		)?;
		let call = Call::<T>::approve_deposit{ bit_map: BIT_MAP, bls_signature: SIGNATURE.into(), token_type: TokenType::Fungible(1), payload: PAYLOAD.into()};
	}: { call.dispatch_bypass_filter(RawOrigin::Signed(origin.clone()).into())? }
	verify {
		let acc =
			T::AccountId::decode(&mut ID.as_ref()).unwrap();
		let n = ApprovedDeposits::<T>::get(&acc).unwrap()[0].clone();
		assert_last_event::<T>(Event::<T>::DepositApproved(
			1,
			acc,
			n.asset_id,
			10,
			H256::zero(),
		).into());
	}

	claim_deposit {
		let a in 0 .. 255;
		let m in 100 .. u32::MAX;
		let account: T::AccountId = account::<T::AccountId>("target", a, 0);
		let asset_id = AssetId::Concrete(MultiLocation { parents: 1, interior: Junctions::Here });
		<T as pallet::Config>::Currency::make_free_balance_be(&account, <T as pallet::Config>::Currency::minimum_balance());
		let so = <T as asset_handler::pallet::Config>::AssetCreateUpdateOrigin::successful_origin();
		let asset = H160::decode(&mut [218, 193, 127, 149, 141, 46, 229, 35, 162, 32, 98, 6, 153, 69, 151, 193, 61, 131, 30, 199].as_ref()).unwrap();
		let id: BoundedVec<u8, ConstU32<1000>> = [218, 193, 127, 149, 141, 46, 229, 35, 162, 32, 98, 6, 153, 69, 151, 193, 61, 131, 30, 199].to_vec().try_into().unwrap();
		asset_handler::pallet::Pallet::<T>::allowlist_token(so.clone(), asset)?;
		asset_handler::pallet::Pallet::<T>::create_thea_asset(so, 0, 5u8, id)?;
		// generate max number of deposits
		let mut ad = vec!();
		for i in 1..101u128 {
			let d = ApprovedDeposit {
				recipient: account.clone(),
				network_id: 1,
				deposit_nonce: i as u32,
				amount: i.saturating_add(100_000).saturating_mul(100_000),
				asset_id: 160841217895665318099328190891344000446 ,
				tx_hash: [i as u8; 32].into(),
			};
			ad.push(d);
		}
		let ad: BoundedVec<
			ApprovedDeposit<<T as frame_system::Config>::AccountId>,
			ConstU32<100>,
		> = ad.try_into().unwrap();
		<ApprovedDeposits<T>>::insert(account.clone(), ad);
		let call = Call::<T>::claim_deposit{ num_deposits: 100 };
	}: { call.dispatch_bypass_filter(RawOrigin::Signed(account.clone()).into())? }
	verify {
		assert!(ApprovedDeposits::<T>::get(account).is_none());
	}

	// works
	batch_withdrawal_complete {
		let origin = account::<T::AccountId>("1", 0, 0);
		let hash = H256::zero();
		const MAP: u128 = 7;
		WithdrawalNonces::<T>::insert(1, 7);
		const PK: [u8; 64] = [1u8; 64];
		TheaPublicKey::<T>::insert(1, PK);
		RelayersBLSKeyVector::<T>::insert(1, vec!(PK1, PK2, PK3));
		const SIG: [u8; 96] = [3, 93, 156, 87, 199, 252, 234, 160, 116, 147, 65, 175, 49, 56, 44, 170, 47, 205, 1, 118, 217, 79, 120, 100, 141, 133, 142, 142, 97, 246, 97, 215, 187, 208, 190, 15, 177, 176, 109, 102, 204, 108, 156, 96, 136, 129, 236, 48, 3, 63, 59, 81, 56, 87, 193, 239, 23, 54, 154, 72, 234, 6, 55, 208, 226, 187, 139, 141, 155, 173, 175, 204, 93, 57, 93, 230, 172, 60, 137, 44, 247, 115, 147, 154, 47, 104, 129, 117, 47, 34, 63, 1, 105, 126, 15, 28];
		let call = Call::<T>::batch_withdrawal_complete{ withdrawal_nonce: 7, network: 1, tx_hash: hash,  bit_map: MAP, bls_signature: SIG};
	}: { call.dispatch_bypass_filter(RawOrigin::Signed(origin).into())? }
	verify {
		assert_last_event::<T>(Event::<T>::WithdrawalExecuted(7, 1, hash).into());
	}

	// works
	withdraw {
		let origin = account::<T::AccountId>("1", 0, 0);
		TheaKeyRotation::<T>::insert(1, false);
		let mut withdrawals = vec![];
		const PL: [u8; 45] = [1, 4, 0, 1, 0, 0, 161, 15, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
		const ASSET_ID: u128 = 313675452054768990531043083915731189857;
		const BF: [u8; 32] = [1u8; 32];
		for _ in 1..=10 {
			withdrawals.push(ApprovedWithdraw {
				asset_id: ASSET_ID,
				amount: 1000,
				network: 1,
				beneficiary: BF.to_vec(),
				payload: PL.to_vec(),
				index: 0,
			});
		}
		pallet::Pallet::<T>::set_withdrawal_fee(RawOrigin::Root.into(), 1, 0)?;
		pallet_balances::pallet::Pallet::<T>::set_balance(
			RawOrigin::Root.into(),
			unlookup::<T>(origin.clone()),
			to_balance::<T>(1_000_000_000_000u128),
			to_balance::<T>(0u128),
		)?;
		let asset_id = AssetId::Concrete(MultiLocation { parents: 1, interior: Junctions::Here });
		asset_handler::pallet::Pallet::<T>::create_parachain_asset(
			<T as asset_handler::pallet::Config>::AssetCreateUpdateOrigin::successful_origin(),
			Box::from(asset_id)
		)?;
		pallet_assets::pallet::Pallet::<T>::mint_into(
			<T as pallet_assets::Config>::AssetId::decode(&mut ASSET_ID.to_le_bytes().as_ref()).unwrap(),
			&origin,
			<T as pallet_assets::Config>::Balance::decode(&mut 1_000_000_000_000u128.to_le_bytes()
				.as_ref())
				.unwrap()
		)?;
		let call = Call::<T>::withdraw{ asset_id: ASSET_ID, amount: 1000, beneficiary: BF.to_vec(), pay_for_remaining: true };
	}: { call.dispatch_bypass_filter(RawOrigin::Signed(origin).into())? }
	verify{
		assert_last_event::<T>(Event::<T>::WithdrawalReady(1, 0).into());
	}

	// works
	set_withdrawal_fee {
		let call = Call::<T>::set_withdrawal_fee{ network_id: 1, fee: u128::MAX };
	}: { call.dispatch_bypass_filter(RawOrigin::Root.into())? }
	verify {
		assert_last_event::<T>(Event::<T>::WithdrawalFeeSet(1, u128::MAX).into());
	}

	// works
	thea_key_rotation_complete {
		let origin = account::<T::AccountId>("1", 0, 0);
		RelayersBLSKeyVector::<T>::insert(1, vec!(PK1, PK2, PK3));
		QueuedTheaPublicKey::<T>::insert(1, [1u8; 64]);
		const SIG: [u8; 96] = [19, 174, 48, 9, 241, 0, 61, 114, 151, 20, 39, 249, 97, 153, 42, 162, 57, 2, 115, 248, 31, 233, 45, 224, 147, 59, 131, 91, 42, 234, 148, 71, 255, 48, 197, 252, 175, 24, 80, 207, 208, 126, 117, 18, 246, 224, 141, 247, 5, 105, 142, 34, 126, 215, 216, 34, 171, 58, 168, 92, 100, 39, 129, 98, 145, 92, 189, 44, 146, 232, 2, 197, 248, 101, 237, 8, 213, 32, 244, 205, 170, 234, 225, 246, 4, 31, 34, 133, 104, 49, 123, 189, 249, 103, 135, 143];
		let call = Call::<T>::thea_key_rotation_complete{ network: 1, tx_hash: H256::zero(), bit_map: 7, bls_signature: SIG };
	}: { call.dispatch_bypass_filter(RawOrigin::Signed(origin).into())? }
	verify {
		assert!(!IngressMessages::<T>::get().is_empty());
	}

	// works
	set_thea_key_complete {
		let origin = account::<T::AccountId>("1", 0, 0);
		RelayersBLSKeyVector::<T>::insert(1, vec!(PK1, PK2, PK3));
		TheaPublicKey::<T>::insert(1, [2u8; 64]);
		QueuedTheaPublicKey::<T>::insert(1, [1u8; 64]);
		const PK: [u8; 64] = [1u8; 64];
		const MAP: u128 = 7;
		const SIG: [u8; 96] = [24, 133, 148, 191, 177, 175, 155, 152, 176, 84, 27, 162, 31, 118, 161, 171, 127, 27, 11, 76, 242, 182, 243, 188, 69, 159, 83, 93, 255, 192, 48, 87, 85, 46, 201, 11, 109, 64, 7, 130, 101, 123, 106, 122, 91, 192, 8, 115, 1, 59, 27, 77, 176, 61, 187, 8, 176, 17, 222, 255, 63, 219, 15, 196, 22, 160, 59, 246, 65, 5, 17, 3, 195, 2, 7, 231, 205, 220, 182, 74, 169, 173, 80, 120, 28, 251, 130, 222, 92, 125, 68, 125, 202, 70, 86, 40];
		let call = Call::<T>::set_thea_key_complete{ network: 1, public_key: PK, bit_map: MAP, bls_signature: SIG };
	}: { call.dispatch_bypass_filter(RawOrigin::Signed(origin).into())? }
	verify {
		let index = TheaSessionId::<T>::get(1);
		assert_last_event::<T>(Event::<T>::TheaKeyUpdated(1, index - 1).into());
	}

	// works
	thea_queued_queued_public_key {
		let origin1 = account::<T::AccountId>("1", 0, 0);
		let origin2 = account::<T::AccountId>("2", 0, 0);
		let origin3 = account::<T::AccountId>("3", 0, 0);
		const PK: [u8; 64] = [1u8; 64];
		RelayersBLSKeyVector::<T>::insert(1, vec!(PK1, PK2, PK3));
		QueuedTheaPublicKey::<T>::insert(1, PK);

		pallet_balances::pallet::Pallet::<T>::set_balance(RawOrigin::Root.into(), unlookup::<T>(origin1.clone()), to_balance::<T>(1_000_000_000_000u128), to_balance::<T>(0u128))?;
		pallet_balances::pallet::Pallet::<T>::set_balance(RawOrigin::Root.into(), unlookup::<T>(origin2.clone()), to_balance::<T>(1_000_000_000_000u128), to_balance::<T>(0u128))?;
		pallet_balances::pallet::Pallet::<T>::set_balance(RawOrigin::Root.into(), unlookup::<T>(origin3.clone()), to_balance::<T>(1_000_000_000_000u128), to_balance::<T>(0u128))?;

		thea_staking::pallet::Pallet::<T>::add_candidate(RawOrigin::Signed(origin1.clone()).into(), 1, PK1)?;
		thea_staking::pallet::Pallet::<T>::add_candidate(RawOrigin::Signed(origin2).into(), 1, PK2)?;
		thea_staking::pallet::Pallet::<T>::add_candidate(RawOrigin::Signed(origin3).into(), 1, PK3)?;

		thea_staking::pallet::Pallet::<T>::add_network(RawOrigin::Root.into(), 1)?;

		thea_staking::pallet::Pallet::<T>::rotate_session();
		thea_staking::pallet::Pallet::<T>::rotate_session();
		const SIG: [u8; 96] = [24, 133, 148, 191, 177, 175, 155, 152, 176, 84, 27, 162, 31, 118, 161, 171, 127, 27, 11, 76, 242, 182, 243, 188, 69, 159, 83, 93, 255, 192, 48, 87, 85, 46, 201, 11, 109, 64, 7, 130, 101, 123, 106, 122, 91, 192, 8, 115, 1, 59, 27, 77, 176, 61, 187, 8, 176, 17, 222, 255, 63, 219, 15, 196, 22, 160, 59, 246, 65, 5, 17, 3, 195, 2, 7, 231, 205, 220, 182, 74, 169, 173, 80, 120, 28, 251, 130, 222, 92, 125, 68, 125, 202, 70, 86, 40];
		let call = Call::<T>::thea_queued_queued_public_key{ network: 1, public_key: PK, bit_map: 7, bls_signature: SIG};
	}: { call.dispatch_bypass_filter(RawOrigin::Signed(origin1).into())? }
	verify {
		assert!(QueuedQueuedTheaPublicKey::<T>::get(1).is_some());
	}

	// works
	thea_relayers_reset_rotation {
		let call = Call::<T>::thea_relayers_reset_rotation{ network: 1 };
	}: { call.dispatch_bypass_filter(RawOrigin::Root.into())? }
}

#[cfg(test)]
use frame_benchmarking::impl_benchmark_test_suite;

#[cfg(test)]
use crate::Pallet as Thea;

#[cfg(test)]
impl_benchmark_test_suite!(Thea, crate::mock::new_test_ext(), crate::mock::Test);
