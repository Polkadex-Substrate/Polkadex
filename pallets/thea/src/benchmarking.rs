// This file is part of Polkadex.

// Copyright (C) 2020-2023 Polkadex o√º.
// SPDX-License-Identifier: GPL-3.0-or-later WITH Classpath-exception-2.0

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program. If not, see <https://www.gnu.org/licenses/>.

//! Benchmarking setup for pallet-thea
//#![cfg(feature = "runtime-benchmarks")]

use super::*;
use crate::Pallet as Thea;
use frame_benchmarking::{account, benchmarks};
use frame_support::{dispatch::UnfilteredDispatchable, traits::EnsureOrigin, BoundedVec};
use frame_system::{Config, RawOrigin};
use pallet_balances as _;
use sp_core::H160;
use sp_runtime::traits::{ConstU32, Zero};
use sp_std::{boxed::Box, vec};
use thea_primitives::{
	parachain_primitives::{AssetType, ParachainAsset, ParachainDeposit, ParachainWithdraw},
	ApprovedWithdraw, TokenType,
};
use xcm::{
	latest::{AssetId, Fungibility, Junction, Junctions, MultiAsset, MultiLocation, NetworkId},
	prelude::X1,
};

// Check if last event generated by pallet is the one we're expecting
fn assert_last_event<T: Config>(generic_event: <T as Config>::Event) {
	frame_system::Pallet::<T>::assert_last_event(generic_event.into());
}

const SIGNATURE: [u8; 96] = [
	21, 215, 123, 153, 74, 251, 176, 4, 118, 253, 52, 161, 223, 105, 74, 124, 80, 152, 195, 211,
	222, 15, 76, 227, 1, 21, 96, 250, 249, 16, 65, 144, 170, 210, 168, 32, 155, 107, 106, 238, 7,
	51, 96, 177, 155, 14, 209, 10, 20, 148, 25, 173, 104, 18, 72, 175, 131, 8, 188, 212, 239, 232,
	177, 162, 1, 168, 49, 28, 230, 119, 43, 202, 83, 195, 141, 21, 239, 96, 1, 165, 163, 182, 182,
	61, 166, 172, 197, 228, 0, 183, 91, 79, 87, 106, 205, 198,
];
const BIT_MAP: u128 = 3;
const PAYLOAD: [u8; 78] = [
	0, 1, 1, 0, 6, 196, 28, 36, 60, 116, 41, 76, 197, 21, 40, 124, 17, 142, 128, 189, 115, 168,
	219, 199, 151, 158, 208, 8, 177, 131, 105, 116, 42, 17, 129, 26, 0, 1, 0, 0, 40, 1, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
];
const ID: [u8; 32] = [
	6, 196, 28, 36, 60, 116, 41, 76, 197, 21, 40, 124, 17, 142, 128, 189, 115, 168, 219, 199, 151,
	158, 208, 8, 177, 131, 105, 116, 42, 17, 129, 26,
];

benchmarks! {
	where_clause { where T: pallet::Config + asset_handler::pallet::Config }

	approve_deposit {
		let origin = account::<T::AccountId>("1", 0, 0);
		let multi_asset = MultiAsset {
			id: AssetId::Concrete(MultiLocation { parents: 1, interior: Junctions::Here }),
			fun: Fungibility::Fungible(10_u128),
		};
		let multi_location = MultiLocation {
			parents: 0,
			interior: X1(Junction::AccountId32 {
				network: NetworkId::Any,
				id: ID,
			}),
		};
		let new_payload = ParachainDeposit {
			recipient: multi_location,
			asset_and_amount: multi_asset,
			deposit_nonce: 1,
			transaction_hash: sp_core::H256::zero(),
			network_id: 1,
		};
		let asset_id = AssetId::Concrete(MultiLocation { parents: 1, interior: Junctions::Here });
		asset_handler::pallet::Pallet::<T>::create_parachain_asset(
			RawOrigin::Signed(origin.clone()).into(),
			Box::from(asset_id)
		)?;
		let call = Call::<T>::approve_deposit{ bit_map: BIT_MAP, bls_signature: SIGNATURE.into(), token_type: TokenType::Fungible(1), payload: PAYLOAD.into()};
	}: { call.dispatch_bypass_filter(RawOrigin::Signed(origin).into())? }

	claim_deposit {
		let a in 0 .. 255;
		let m in 100 .. u32::MAX;
		let account: T::AccountId = account::<T::AccountId>("target", a, 0);
		<T as pallet::Config>::Currency::make_free_balance_be(&account, <T as pallet::Config>::Currency::minimum_balance());
		// generate max number of deposits
		let mut ad = vec!();
		for i in 1..101u128 {
			let d = ApprovedDeposit {
				recipient: account.clone(),
				network_id: 1,
				deposit_nonce: i as u32,
				amount: i.saturating_add(100_000).saturating_mul(100_000),
				asset_id: 160841217895665318099328190891344000446,
				tx_hash: [i as u8; 32].into(),
			};
			ad.push(d);
		}
		let ad: BoundedVec<
			ApprovedDeposit<<T as frame_system::Config>::AccountId>,
			ConstU32<100>,
		> = ad.try_into().unwrap();
		<ApprovedDeposits<T>>::insert(account.clone(), ad);
		let call = Call::<T>::claim_deposit{ num_deposits: 100 };
	}: { call.dispatch_bypass_filter(RawOrigin::Signed(account).into())? }

	batch_withdrawal_complete {
		let call = Call::<T>::batch_withdrawal_complete{ };
	}: { call.dispatch_bypass_filter(RawOrigin::Signed(1).into())? }
	verify {
		//assert_last_event::<T>(Event::Nominated { candidate, nominator }.into());
	}

	withdraw {
		let call = Call::<T>::withdraw{};
	}: { call.dispatch_bypass_filter(RawOrigin::Signed(1).into())? }
	verify{
		//assert_last_event::<T>(Event::Bonded{ candidate, nominator, amount }.into());
	}

	set_withdrawal_fee {
		let call = Call::<T>::set_withdrawal_fee{ };
	}: { call.dispatch_bypass_filter(RawOrigin::Signed(1).into())? }
	verify {
		//assert_last_event::<T>(Event::Unbonded{ candidate, nominator, amount }.into());
	}

	thea_key_rotation_complete {
		let call = Call::<T>::thea_key_rotation_complete{};
	}: { call.dispatch_bypass_filter(RawOrigin::Signed(1).into())? }
	verify {
		//assert_last_event::<T>(Event::BondsWithdrawn{ nominator, amount }.into());
	}

	set_thea_key_complete {
		let call = Call::<T>::set_thea_key_complete{  };
	}: { call.dispatch_bypass_filter(RawOrigin::Signed(1).into())? }
	verify {
		//assert_last_event::<T>(Event::OutgoingCandidateAdded{ candidate }.into());
	}

	thea_queued_queued_public_key {
		let call = Call::<T>::thea_queued_queued_public_key{};
	}: { call.dispatch_bypass_filter(RawOrigin::Signed(1).into())? }
	verify {
		//assert_last_event::<T>(Event::NetworkAdded{ network }.into());
	}

	thea_relayers_reset_rotation {
		let call = Call::<T>::thea_relayers_reset_rotation{ network: 1 };
	}: { call.dispatch_bypass_filter(RawOrigin::Signed(1).into())? }
	verify {
		//assert_last_event::<T>(Event::NetworkRemoved{ network }.into());
	}
}

#[cfg(test)]
use frame_benchmarking::impl_benchmark_test_suite;

#[cfg(test)]
impl_benchmark_test_suite!(Thea, crate::mock::new_test_ext(), crate::mock::Test);
