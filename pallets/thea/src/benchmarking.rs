// This file is part of Polkadex.

// Copyright (C) 2020-2022 Polkadex o√º.
// SPDX-License-Identifier: GPL-3.0-or-later WITH Classpath-exception-2.0

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program. If not, see <https://www.gnu.org/licenses/>.

//! Benchmarking setup for pallet-thea

use super::{Pallet as Thea, *};
use codec::Decode;
use frame_benchmarking::{account, benchmarks};
use frame_support::BoundedVec;
use frame_system::RawOrigin;
use sp_runtime::traits::BlockNumberProvider;
use thea_primitives::{
	keygen::Msg, MsgLimit, MsgVecLimit, PartialSignatureLimit, PartialSignatureVecLimit,
};

// Check if last event generated by pallet is the one we're expecting
fn assert_last_event<T: Config>(generic_event: <T as Config>::Event) {
	frame_system::Pallet::<T>::assert_last_event(generic_event.into());
}

// Generate Thea signature for extrinsics calls
fn gen_signature<T: pallet::Config>(
	base: u8,
) -> <<T as pallet::Config>::TheaId as sp_runtime::RuntimeAppPublic>::Signature {
	let sig_base = [base; 64].to_vec();
	<<T as pallet::Config>::TheaId as sp_runtime::RuntimeAppPublic>::Signature::decode(
		&mut sig_base.as_ref(),
	)
	.unwrap()
}

// All benchmarks names match extrinsic names so we call them with `_()`
benchmarks! {
	// step may happen within u8 range
	// signature will be [`b`; 64] on each step to have some versatility - does nothing to actual performance
	// as extrinsic pretty much stores given values to storage - nothing to simulate as worse case scenario here
	// WORKS
	submit_keygen_message {
		let b in 0 .. 255;
		let no_caller = RawOrigin::None;
		let signature = gen_signature::<T>(b as u8);
		let msg: Vec<Msg<MsgLimit>> = (0..255).into_iter().map(|count| Msg {receiver: Some(count as u16), message: Default::default(), sender: count as u16}).collect();
		let mut payload: TheaPayload<T::TheaId, KeygenRound, MsgLimit, MsgVecLimit> = Default::default();
		let mut bonded = BoundedVec::with_bounded_capacity(msg.len());
		msg.into_iter().for_each(|msg| {
			// we know we have capacity as we've created matching inner
			let _ = bonded.try_push(msg);
		});
		payload.messages = bonded;
		let id = T::TheaId::decode(&mut [b as u8; 64].as_ref()).unwrap();
		payload.signer = Some(id.clone());
	}: _(no_caller, payload.clone(), signature, b.into())
	verify {
		assert_last_event::<T>(Event::KeygenMessages(id, payload).into());
	}

	// step may happen within u8 range
	// signature will be [`b`; 64] on each step to have some versatility - does nothing to actual performance
	// extrinsic is removing values from the storage - inserting them in setup, then call extrinsic to do the math
	// no worse case scenario here as all inputs are of same constant sizes
	// WORKS
	clean_keygen_messages {
		let b in 0 .. 255;
		let no_caller = RawOrigin::None;
		let signature = gen_signature::<T>(b as u8);
		let round = thea_primitives::keygen::KeygenRound::Round0;
		let offline_round = thea_primitives::keygen::OfflineStageRound::Round0;
		let msg: Vec<Msg<MsgLimit>> = (0..255).into_iter().map(|count| Msg {receiver: Some(count as u16), message: Default::default(), sender: count as u16}).collect();
		let mut payload: TheaPayload<T::TheaId, KeygenRound, MsgLimit, MsgVecLimit> = Default::default();
		payload.set_id = b as u64 + 10;
		let mut bonded = BoundedVec::with_bounded_capacity(msg.len());
		msg.into_iter().for_each(|msg| {
			// we know we have capacity as we've created matching inner
			let _ = bonded.try_push(msg);
		});
		payload.messages = bonded.clone();
		let mut offline_payload: TheaPayload<T::TheaId, OfflineStageRound, MsgLimit, MsgVecLimit> = Default::default();
		offline_payload.set_id = b as u64 + 22;
		offline_payload.messages = bonded;
		<KeygenMessages<T>>::insert(b as u16 + 1, round, payload); // + 1 to make sure it's not 0 (Default)
		<OfflineMessages<T>>::insert(b as u16 + 1, (offline_round, [b as u8; 32]), offline_payload); // + 1 to make sure it's not 0 (Default)
	}: _(no_caller, b as u16 + 1, signature, b as u64)
	verify {
		assert_last_event::<T>(Event::MessagesCleaned(b as u16 + 1).into());
	}

	// step may happen within u8 range
	// signature will be [`b`; 64] on each step to have some versatility - does nothing to actual performance
	// no checks are happening and extrinsic is insertion into storage - no worse case scenario here possible
	// WORKS
	submit_offline_message {
		let b in 0 .. 255;
		let no_caller = RawOrigin::None;
		let signature = gen_signature::<T>(b as u8);
		let mut offline_payload: TheaPayload<T::TheaId, OfflineStageRound, MsgLimit, MsgVecLimit> = Default::default();
		offline_payload.set_id = b as u64 + 22;
		let signer = T::TheaId::decode(&mut [b as u8; 64].as_ref()).unwrap();
		offline_payload.signer = Some(signer.clone());
	}: _(no_caller, offline_payload.clone(), [b as u8; 32], signature, b as u64)
	verify {
		assert_last_event::<T>(Event::OfflineMessages(offline_payload.signer.clone().unwrap(), offline_payload).into());
	}

	// step may happen within u8 range
	// signature will be [`b`; 64] on each step to have some versatility - does nothing to actual performance
	// no checks are happening and extrinsic is insertion into storage - no worse case scenario here possible
	// WORKS
	submit_signing_message {
		let b in 0 .. 255;
		let no_caller = RawOrigin::None;
		let signature = gen_signature::<T>(b as u8);
		let mut signing_session_payload: SigningSessionPayload<T::TheaId, PartialSignatureLimit, PartialSignatureVecLimit> = Default::default();
		signing_session_payload.auth_idx = b as u16 + 8;
		let signer = T::TheaId::decode(&mut [b as u8; 64].as_ref()).unwrap();
		signing_session_payload.signer = Some(signer.clone());
	}: _(no_caller, b.into(), signing_session_payload.clone(), signature, b as u64)
	verify {
		assert_last_event::<T>(Event::SigningMessages(signer, signing_session_payload).into());
	}

	// step may happen within u8 range
	// signature will be [`b`; 64] on each step to have some versatility - does nothing to actual performance
	// this one can get really heavy so we generate maximum sized vector (per platform's word size) and submit
	// WORKS
	submit_signed_payload {
		let b in 0 .. 255;
		let no_caller = RawOrigin::None;
		let block_no = frame_system::Pallet::<T>::current_block_number();
			let payload = UnsignedTheaPayload {
				network: Network::ETHEREUM,
				payload: [b as u8; 32],
				submission_blk: block_no.unique_saturated_into()
			};
			let signature = sp_core::ecdsa::Signature::try_from([b as u8; 65].as_ref()).unwrap();
			let signed_payload = SignedTheaPayload  {
				payload,
				signature: signature.into()
			};
	}: _(no_caller, signed_payload, b as u64)
	verify {
		assert_last_event::<T>(Event::SignedPayloadSubmitted([b as u8; 32]).into());
	}

	// simple get-set storage operation extrinsic
	// inputs of same size - no worse case scenario possible
	// payload is b times 32
	// WORKS
	//submit_payload {
	//	let b in 0 .. 255;
	//	let no_caller = RawOrigin::None;
	//	let block_no = frame_system::Pallet::<T>::current_block_number();
	//}: _(no_caller, Network::ETHEREUM, [b as u8; 32], b as u64)
	//verify {
	//	assert_last_event::<T>(Event::PayloadSubmitted([b as u8; 32]).into());
	//}

	// simple insert of the key into the storage
	// no worse case scenario possible here
	// key is always `b` times 33
	// WORKS
	submit_ecdsa_public_key {
		let b in 0 .. 255;
		let no_caller = RawOrigin::None;
		let public = sp_core::ecdsa::Public([b as u8; 33]);
	}: _(no_caller, b as u64, public.clone())
	verify {
		assert_last_event::<T>(Event::ECDSAKeySet(b as u64, public).into());
	}

	// deposit address storage insertion
	// payload is of constant size - no worse case scenario possible
	// WORKS
	register_deposit_address {
		let caller = account("caller", 0, 0);
	}: _(RawOrigin::Signed(caller))
	verify {
		assert_last_event::<T>(Event::NewDepositAddressRegistered(account("caller", 0, 0)).into());
	}

	// test module registration
	impl_benchmark_test_suite!(Thea, crate::mock::new_test_ext(), crate::mock::Test);
}
