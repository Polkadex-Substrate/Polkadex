// This file is part of Polkadex.
//
// Copyright (c) 2022-2023 Polkadex o√º.
// SPDX-License-Identifier: GPL-3.0-or-later WITH Classpath-exception-2.0
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <https://www.gnu.org/licenses/>.

use crate::pallet::{Pallet as AssetHandler, *};
use frame_benchmarking::{account, benchmarks};
use frame_support::{dispatch::UnfilteredDispatchable, traits::EnsureOrigin};
use frame_system::RawOrigin;
use parity_scale_codec::{Decode, Encode};
use sp_core::H160;
use sp_runtime::SaturatedConversion;

const SEED: u32 = 0;
pub const UNIT_BALANCE: u128 = 1000_000_000_000;

// Check if last event generated by pallet is the one we're expecting
fn assert_last_event<T: Config>(generic_event: <T as Config>::RuntimeEvent) {
	frame_system::Pallet::<T>::assert_last_event(generic_event.into());
}

benchmarks! {
	add_precision {
		let b in 0 .. 255;
		let origin = T::AssetCreateUpdateOrigin::successful_origin();
		let rid = [b as u8; 32];
		let precision_type = PrecisionType::LowPrecision(u128::MAX);
		let call = Call::<T>::add_precision { rid, precision_type };
	}: { call.dispatch_bypass_filter(origin)? }
	verify {
		assert_eq!(AssetPrecision::<T>::get(rid), precision_type);
	}

	create_asset {
		let b in 0 .. 255;
		let origin = T::AssetCreateUpdateOrigin::successful_origin();
		let chain_id = 1;
		let id = H160::from_slice(&[b as u8; 20]);
		let rid = chainbridge::derive_resource_id(chain_id, &id.0);
		let call = Call::<T>::create_asset { chain_id, contract_add: id, precision_type: PrecisionType::LowPrecision(1000000) };
	}: { call.dispatch_bypass_filter(origin)? }
	verify {
		assert_last_event::<T>(Event::AssetRegistered(rid).into());
	}

	mint_asset {
		let b in 1 .. 1000;
		let chain_id = 1;
		let id = H160::from_slice(&[b as u8; 20]);
		let rid = chainbridge::derive_resource_id(chain_id, &id.0);
		Pallet::<T>::register_asset(rid);
		let relayer: T::AccountId = account("relayer", 1, SEED);
		chainbridge::pallet::Pallet::<T>::insert_relayer(relayer.clone());
		let recipient: T::AccountId = account("recipient", b, SEED);
		let encoded_recipient = recipient.encode();
		let recipient: [u8;32] = encoded_recipient.as_slice().try_into().unwrap();
		let destination_acc = T::AccountId::decode(&mut &recipient[..]).unwrap();
		let amount = b as u128 * UNIT_BALANCE;
	}: _(RawOrigin::Signed(chainbridge::Pallet::<T>::account_id()), recipient.clone().to_vec(), amount, rid)
	verify {
		assert_last_event::<T>(Event::AssetDeposited(destination_acc, rid, amount).into());
	}

	set_bridge_status {
		let status = true;
	}: _(RawOrigin::Root, status)
	verify {
		assert_last_event::<T>(Event::BridgeStatusUpdated(status).into());
	}

	set_block_delay {
		let block_delay = 10u64;
		let block_delay = block_delay.saturated_into::<T::BlockNumber>();
	}: _(RawOrigin::Root, block_delay)
	verify {
		assert_last_event::<T>(Event::BlocksDelayUpdated(block_delay).into());
	}

	update_fee {
		let m in 1 .. 100;
		let f in 1 .. 1000;
		let chain_id = m as u8;
		let min_fee = (m as u128).saturated_into::<BalanceOf<T>>();
		let fee_scale = f as u32;
	}: _(RawOrigin::Root, chain_id, min_fee, fee_scale)
	verify {
		assert_last_event::<T>(Event::FeeUpdated(chain_id, min_fee).into());
	}

	withdraw {
		let b in 10 .. 1000;
		let c in 1010 .. 2000;
		let chain_id = 0;
		chainbridge::pallet::Pallet::<T>::allowlist(chain_id).unwrap();
		let id = H160::from_slice(&[1; 20]);
		let rid = chainbridge::derive_resource_id(chain_id, &id.0);
		Pallet::<T>::register_asset(rid);
		let account: T::AccountId = account("withdraw", b, SEED);
		let deposit_amount = 1000;
		let mut bts = <AllowlistedToken<T>>::get();
		bts.try_insert(id).unwrap();
		<AllowlistedToken<T>>::put(bts);
		Pallet::<T>::mint_token(account.clone(), rid, deposit_amount);
		let withdraw_amount = (100 as u128).saturated_into::<BalanceOf<T>>();
		// Set Fee
		let recipeint = H160::from_slice(&[c as u8; 20]);
	}: _(RawOrigin::Signed(account), chain_id, id, withdraw_amount, recipeint)
	verify {
		assert_last_event::<T>(Event::AssetWithdrawn(id, rid, withdraw_amount).into());
	}

	allowlist_token {
		let b in 0 .. 225; // must not overflow u8
		let origin = T::AssetCreateUpdateOrigin::successful_origin();
		let token_add = H160::decode(&mut [b as u8; 48].as_ref()).unwrap();
		let call = Call::<T>::allowlist_token { token_add };
	}: { call.dispatch_bypass_filter(origin)? }
	verify {
		assert_last_event::<T>(Event::AllowlistedTokenAdded(token_add).into());
	}

	remove_allowlisted_token {
		let b in 0 .. 225; // must not overflow u8
		let origin = T::AssetCreateUpdateOrigin::successful_origin();
		let token_add = H160::decode(&mut [b as u8; 48].as_ref()).unwrap();
		AssetHandler::<T>::allowlist_token(origin.clone(), token_add)?;
		let call = Call::<T>::remove_allowlisted_token { token_add };
	}: { call.dispatch_bypass_filter(origin)? }
	verify {
		assert_last_event::<T>(Event::AllowlistedTokenRemoved(token_add).into());
	}
}
